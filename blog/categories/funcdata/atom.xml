<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Funcdata | Technoskald]]></title>
  <link href="http://technoskald.github.io/blog/categories/funcdata/atom.xml" rel="self"/>
  <link href="http://technoskald.github.io/"/>
  <updated>2014-01-09T20:47:27-06:00</updated>
  <id>http://technoskald.github.io/</id>
  <author>
    <name><![CDATA[Kyle Maxwell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Project Euler: Problem 2]]></title>
    <link href="http://technoskald.github.io/blog/2013/12/25/project-euler-problem-2/"/>
    <updated>2013-12-25T13:52:24-06:00</updated>
    <id>http://technoskald.github.io/blog/2013/12/25/project-euler-problem-2</id>
    <content type="html"><![CDATA[<p><em>NB: This is a repost of something I wrote on an old blog. Original post <a href="http://funcdata.wordpress.com/2012/05/11/project-euler-problem-2/">here</a>. Minor edits / additions to update for this newer context.</em></p>

<h2><a href="https://projecteuler.net/problem=2">Problem 2</a>: Each new term in the <a href="http://mathworld.wolfram.com/FibonacciNumber.html">Fibonacci sequence</a> is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,&hellip; By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</h2>

<p>As with problem 1, we could solve this with a traditional imperative approach:</p>

<p>``` python Project Euler Problem 2 the Traditional Way
n=0
a=1
b=2
print &ldquo;Calculating sum&hellip;&rdquo;
while (b &lt;= 4000000):</p>

<pre><code>print "a=",a," b=",b
if (b % 2) == 0:
    n += b
a,b = b,a+b
</code></pre>

<p>print &ldquo;Sum is &rdquo;,n
```</p>

<p>But we can streamline this. First, we observe that F<sub>1</sub> and F<sub>2</sub> (1 and 1, respectively) sum to F<sub>3</sub> = 2. We can also see that F<sub>4</sub>, as the sum of an odd and even, will therefore also be odd, as will F<sub>5</sub> due to being the sum of an even and odd. Clearly every third term must always be even, with the rest odd. So we only need to calculate every third term in the Fibonacci sequence. A bit of high school algebra shows us that:</p>

<p><tt>
F<sub>3</sub> = F<sub>1</sub> + F<sub>2</sub> = F<sub>1</sub> + F<sub>0</sub> + F<sub>1</sub> = F<sub>0</sub> + 2F<sub>1</sub>
</tt></p>

<p><tt>
F<sub>4</sub> = F<sub>2</sub> + F<sub>3</sub> = (F<sub>0</sub> + F<sub>1</sub>) + (F<sub>0</sub> + 2F<sub>1</sub>) = 2F<sub>0</sub> + 3F<sub>1</sub>
</tt></p>

<p>This means we can always skip ahead and just sum those terms.</p>

<p>Now we introduce the concept of a <a href="http://docs.python.org/dev/howto/functional.html#generators">generator</a> in Python. A generator function doesn&rsquo;t have a normal <code>return</code> statement. Instead, it uses <code>yield</code>, which &ldquo;pauses&rdquo; the function and returns a value. But the next time you call the generator to return another value, Python will &ldquo;unpause&rdquo; it and continue processing until it yields (returns) another value. (I&rsquo;ve simplified a bit here because I hate objects.) This effectively creates a list using <strong>list comprehension</strong>, similar to what we did in Problem 1 with the <code>i for i in range()</code> syntax.</p>

<p>So to <a href="https://github.com/technoskald/funcdata/blob/master/projecteuler/p002.py">solve the problem</a>, we write a modified Fibonacci sequence generator and just print its sum. Note that we avoid multiplication as a speed optimization; this actually made a significant difference!</p>

<p>``` python Project Euler Problem 2 the Generator Way
def modfib():</p>

<pre><code>a,b = 0,1
while b &lt; 4000000:
    a,b = a + b + b, a + a + b + b + b
    yield a
</code></pre>

<p>print sum(modfib())
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler: Problem 1]]></title>
    <link href="http://technoskald.github.io/blog/2013/12/25/project-euler-problem-1/"/>
    <updated>2013-12-25T13:28:12-06:00</updated>
    <id>http://technoskald.github.io/blog/2013/12/25/project-euler-problem-1</id>
    <content type="html"><![CDATA[<p><em>NB: This is a repost of something I wrote on an old blog. Original post <a href="http://funcdata.wordpress.com/2012/05/11/project-euler-problem-1/">here</a>. Minor edits / additions to update for this newer context.</em></p>

<h2><a href="https://projecteuler.net/problem=1">Problem 1</a>: Find the sum of all the multiples of 3 or 5 below 1000.</h2>

<p>My <a href="https://github.com/technoskald/projecteuler/blob/master/prob1.py">original solution</a> for this problem, like almost all the others, uses old-school imperative programming that we can do in almost any language.</p>

<p>``` python Project Euler Problem 1 the Easy Way
n=0
for i in range(1000):</p>

<pre><code>if ((i % 3) == 0) or ((i % 5) == 0):
    n += i
</code></pre>

<p>print n
```</p>

<p>More to the point, we can also <a href="https://github.com/technoskald/funcdata/blob/master/projecteuler/p001.py">do this</a> in idiomatic Python:</p>

<p><code>python Project Euler Problem 1 the Pythonic Way
print sum(i for i in range(1,1000) if i%3==0 or i%5==0)
</code></p>

<p>Both give the correct answer<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>, but we used an <a href="http://docs.python.org/glossary.html#term-iterable">iterable</a> (sequence) in the second case to do the same thing as the <code>for</code> loop in the first example. We also don&rsquo;t need to maintain our own summation variable like <code>n</code>. Because of the small range of numbers we need to consider<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>, I couldn&rsquo;t find any significant difference in the average run times of these two programs. And I&rsquo;ve wanted to explore <a href="http://en.wikipedia.org/wiki/Functional_programming">functional programming</a>, too.</p>

<p><code>python Project Euler Problem 1 the Functional Way
print sum(list(set(range(0,1000,3) + range(0,1000,5))))
</code></p>

<p>This avoids maintaining <em>any</em> internal state like we did with the <code>i</code> variable above. For purposes of functional programming, I think that this would have been the optimal solution.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>I won&rsquo;t list the actual problem answers here. I know somebody can just copy and paste the code, but printing the actual answer as opposed to explaining how to solve it feels too much like cheating.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>In some later problems, I&rsquo;ll just get any needed parameters from the command line to facilitate testing and debugging.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | Technoskald]]></title>
  <link href="http://technoskald.github.io/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://technoskald.github.io/"/>
  <updated>2014-01-10T19:39:54-06:00</updated>
  <id>http://technoskald.github.io/</id>
  <author>
    <name><![CDATA[Kyle Maxwell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Project Euler Problem 5]]></title>
    <link href="http://technoskald.github.io/blog/2014/01/20/project-euler-problem-5/"/>
    <updated>2014-01-20T18:50:39-06:00</updated>
    <id>http://technoskald.github.io/blog/2014/01/20/project-euler-problem-5</id>
    <content type="html"><![CDATA[<h2><a href="http://projecteuler.net/problem=5">Problem 5</a>: 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder. What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?</h2>

<p>Around fourth or fifth grade (in the US, usually around 10 or 11 years old), we learned the concept of a <a href="http://en.wikipedia.org/wiki/Least_common_multiple"><strong>least common multiple</strong></a>. While the problem statement doesn&rsquo;t use that specific term, it actually contains a pretty decent definition of it: &ldquo;the smallest number that can be divided by each of the numbers [in a set] without any remainder&rdquo;. <code>LCM(1,2,3,4,5,6,7,8,9,10) == 2520</code> provides a helpful assertion to validate our code before running it on the real problem.</p>

<p>The easiest way for me to understand this problem is to apply the <strong>Fundamental Theorem of Arithmetic</strong> again and get the prime factorization of each number between 1 and the max in the set, exclusive. In other words, we calculate factors of 2 thru 9 for the example in the problem. Fortunately, we wrote code<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> to do this before in <a href="http://technoskald.github.io/blog/2013/12/26/project-euler-problem-3/">Problem 3</a> (see <code>prime_factors()</code> there).</p>

<p>Then for our core logic, we define <code>n</code> as our maximum number and proceed as follows:</p>

<p>``` python Project Euler Problem 5
lcm = 1
factors = {}</p>

<p>for i in range(n-1, 1, -1):</p>

<pre><code>candidate_factors = prime_factors(i)
print "* Factors for %d are: %s" % (i, print_factors(candidate_factors))
for j in candidate_factors:
    if (not j in factors) or (candidate_factors[j] &gt; factors[j]):
        factors[j] = candidate_factors[j]
</code></pre>

<p>print &ldquo;Factors of LCM are %s&rdquo; % print_factors(factors)
for f in factors:</p>

<pre><code>lcm = lcm * f ** factors[f]
</code></pre>

<p>print &ldquo;LCM is %d&rdquo; % lcm
```</p>

<p>For each number in that range, we calculate the prime factorizationi (stored as a dictionary where each key-value pair is a factor consisting of a prime number and the power). Then we build the LCM from finding the highest power of each prime number in all the factorizations. Our test example (<code>n=10</code>) validated so then we re-run with <code>n=20</code>.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Turns out that earlier code had some indentation problems in the blog post (not the actual source on my system, fortunately). All fixed now, sorry.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler: Problem 4]]></title>
    <link href="http://technoskald.github.io/blog/2014/01/09/project-euler-problem-4/"/>
    <updated>2014-01-09T20:37:47-06:00</updated>
    <id>http://technoskald.github.io/blog/2014/01/09/project-euler-problem-4</id>
    <content type="html"><![CDATA[<h2><a href="http://projecteuler.net/problem=4">Problem 4</a>: A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99. Find the largest palindrome made from the product of two 3-digit numbers.</h2>

<p>Palindromic numbers make much more sense to humans than computers because we can look at a number as a series of symbols rather than a scalar value. And of course they only make sense in the context of a given base; clearly we must assume base 10 here, validated by the example given.</p>

<p>First we write a little function to determine whether a given integer value is a palindrome. Python&rsquo;s <a href="http://stackoverflow.com/a/509295/1569808">slice notation</a> makes this easy:</p>

<p>``` python Function to determine whether a number is a palindrome
def is_palindrome(n):</p>

<pre><code>return (str(n) == str(n)[::-1])
</code></pre>

<p><code>``
Basically, appending [</code>[::-1]`](<a href="http://stackoverflow.com/questions/509211/pythons-slice-notation#comment323779_509295">http://stackoverflow.com/questions/509211/pythons-slice-notation#comment323779_509295</a>) gives us the reverse of a list.</p>

<p>With that in mind, we just need a couple of for-loops to iterate over all pairs of three-digit numbers:</p>

<p>``` python Project Euler Problem 4 the obvious way
result = 0
for i in range(100, 1000):</p>

<pre><code>for j in range(100, 1000):
    n = i*j
    if (is_palindrome(n)) and n &gt; result:
        lasti = i
        lastj = j
        result = n
</code></pre>

<p>print &ldquo;%d is the product of %d and %d&rdquo; % (result, lasti, lastj)
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2014 Tech goals]]></title>
    <link href="http://technoskald.github.io/blog/2013/12/29/2014-tech-goals/"/>
    <updated>2013-12-29T14:37:38-06:00</updated>
    <id>http://technoskald.github.io/blog/2013/12/29/2014-tech-goals</id>
    <content type="html"><![CDATA[<p>While the calendar will flip in a few days, I&rsquo;ve had some time off and and naturally have spent some time thinking about the future. What do I want to learn and improve in my technical skills over the next year or so? Most of the following can be summed up in two &ldquo;meta goals&rdquo;: <strong>write more code</strong> and <strong>get back to math and computer science.</strong></p>

<p>At the moment, I plan to work primarily in Python and C,  although that could change depending on projects and other similar factors. Today, I write most of my <a href="http://osrc.dfm.io/technoskald">open source code</a> in Python, and my closed source code for work leans even more heavily in that direction. C was my first love, though, and I still use a subset of it when working with Arduino. Other languages might crop up for specific projects, I suppose.</p>

<ol>
<li><strong>Submit a solid proposal to speak at DEFCON.</strong> I have no direct control over the acceptance of my proposal, but I can make sure that I work on something cool and submit a proposal that&rsquo;s worthy of serious consideration. Almost certainly this will deal with OSINT or network forensics.</li>
<li><strong>Complete the <a href="http://www.matasano.com/articles/crypto-challenges/">Matasano Crypto Challenges</a></strong> This will help me achieve a good hacker-level understanding of cryptography. Recent news events provide part of the motivation to learn a lot more about all this.</li>
<li><strong>Complete at least 100 problems from <a href="http://projecteuler.net">Project Euler</a>, including writeups.</strong> This project scratches a number of different itches for me, all in good ways.</li>
<li><strong>Build at least one really cool hardware project.</strong> I have a recent interest in hardware hacking, mostly around the so-called &ldquo;Internet of Things&rdquo;, and so (likely in conjunction with my daughter) I want to build something cool, albeit undetermined right now.</li>
</ol>


<p>For clarity&rsquo;s sake, of course I have other things I want to accomplish during the next few months to a year. Some of them almost fit here (more educational advocacy and volunteerism) and some don&rsquo;t (personal and family goals). But the above looks to me like a solid set of things to work on.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler: Problem 3]]></title>
    <link href="http://technoskald.github.io/blog/2013/12/26/project-euler-problem-3/"/>
    <updated>2013-12-26T20:00:31-06:00</updated>
    <id>http://technoskald.github.io/blog/2013/12/26/project-euler-problem-3</id>
    <content type="html"><![CDATA[<h2><a href="http://projecteuler.net/problem=3">Problem 3</a>: The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600851475143 ?</h2>

<p><a href="http://en.wikipedia.org/wiki/Integer_factorization">Factorization</a> is, computationally speaking, a Hard Problem. When mathematicians call a problem &ldquo;hard&rdquo;, we don&rsquo;t mean &ldquo;difficult for the human mind to comprehend&rdquo;, because that is subjective and subject to change. Remember, the differential calculus literally changed history when Newton and Leibniz first wrote about it, and now we teach it to kids in high school. No, what we mean in this case<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> is that it can&rsquo;t be solved in polynomial time &ndash; meaning that, for very large numbers, this takes infeasible amounts of time with everything we know about mathematics and computation right now. In fact, it&rsquo;s so hard that it forms the mathematical basis for public-key cryptography.</p>

<p>That doesn&rsquo;t mean we can&rsquo;t do it. It just means that for really, really big numbers, it takes a long time. So this problem isn&rsquo;t actually a large number, on the order of 10<sup>12</sup>. And lots of work has been done with this problem: in fact, it comes down to something called the &ldquo;Fundamental Theorem of Arithmetic&rdquo;, which is that every positive integer has a <em>unique</em> prime factorization.</p>

<p>To facilitate some problems later in Project Euler, I wrote a general-purpose factorization routine that does a little more than we need here.</p>

<p>``` python Integer factorization routine
def prime_factors(n):</p>

<pre><code>""" Return the prime factors of the given number. """
factors = {}
lastresult = n

# 1 is a special case
if n == 1:
    return {1: 1}

while lastresult != 1:
    c = 2
    while lastresult % c != 0:
        c += 1
    if c in factors:
        factors[c] += 1
    else:
        factors[c] = 1
    lastresult /= c

return factors
</code></pre>

<p>```</p>

<p>This will return a Python dict, where each key is a prime factor of the original number and the value of that key is the required power to which we need to raise that factor (e.g. <code>prime_factors(18)</code> returns <code>{2:1, 3:2}</code> for <tt>2<sup>1</sup> * 3<sup>2</sup></tt>).</p>

<p>Then we write a short script to call it with the appropriate number and print only the largest factor.</p>

<p><code>python Project Euler Problem 3 wrapper code
n = 600851475143
factors = prime_factors(n)
print "Largest prime factor of %d is %d" % (n, max(factors.keys()))
</code></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>The &ldquo;hardness&rdquo; of a problem in mathematics is called its &ldquo;complexity&rdquo;. Computational complexity theory is a well-established and important field all on its own.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler: Problem 2]]></title>
    <link href="http://technoskald.github.io/blog/2013/12/25/project-euler-problem-2/"/>
    <updated>2013-12-25T13:52:24-06:00</updated>
    <id>http://technoskald.github.io/blog/2013/12/25/project-euler-problem-2</id>
    <content type="html"><![CDATA[<p><em>NB: This is a repost of something I wrote on an old blog. Original post <a href="http://funcdata.wordpress.com/2012/05/11/project-euler-problem-2/">here</a>. Minor edits / additions to update for this newer context.</em></p>

<h2><a href="https://projecteuler.net/problem=2">Problem 2</a>: Each new term in the <a href="http://mathworld.wolfram.com/FibonacciNumber.html">Fibonacci sequence</a> is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,&hellip; By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</h2>

<p>As with problem 1, we could solve this with a traditional imperative approach:</p>

<p>``` python Project Euler Problem 2 the Traditional Way
n=0
a=1
b=2
print &ldquo;Calculating sum&hellip;&rdquo;
while (b &lt;= 4000000):</p>

<pre><code>print "a=",a," b=",b
if (b % 2) == 0:
    n += b
a,b = b,a+b
</code></pre>

<p>print &ldquo;Sum is &rdquo;,n
```</p>

<p>But we can streamline this. First, we observe that F<sub>1</sub> and F<sub>2</sub> (1 and 1, respectively) sum to F<sub>3</sub> = 2. We can also see that F<sub>4</sub>, as the sum of an odd and even, will therefore also be odd, as will F<sub>5</sub> due to being the sum of an even and odd. Clearly every third term must always be even, with the rest odd. So we only need to calculate every third term in the Fibonacci sequence. A bit of high school algebra shows us that:</p>

<p><tt>
F<sub>3</sub> = F<sub>1</sub> + F<sub>2</sub> = F<sub>1</sub> + F<sub>0</sub> + F<sub>1</sub> = F<sub>0</sub> + 2F<sub>1</sub>
</tt></p>

<p><tt>
F<sub>4</sub> = F<sub>2</sub> + F<sub>3</sub> = (F<sub>0</sub> + F<sub>1</sub>) + (F<sub>0</sub> + 2F<sub>1</sub>) = 2F<sub>0</sub> + 3F<sub>1</sub>
</tt></p>

<p>This means we can always skip ahead and just sum those terms.</p>

<p>Now we introduce the concept of a <a href="http://docs.python.org/dev/howto/functional.html#generators">generator</a> in Python. A generator function doesn&rsquo;t have a normal <code>return</code> statement. Instead, it uses <code>yield</code>, which &ldquo;pauses&rdquo; the function and returns a value. But the next time you call the generator to return another value, Python will &ldquo;unpause&rdquo; it and continue processing until it yields (returns) another value. (I&rsquo;ve simplified a bit here because I hate objects.) This effectively creates a list using <strong>list comprehension</strong>, similar to what we did in Problem 1 with the <code>i for i in range()</code> syntax.</p>

<p>So to <a href="https://github.com/technoskald/funcdata/blob/master/projecteuler/p002.py">solve the problem</a>, we write a modified Fibonacci sequence generator and just print its sum. Note that we avoid multiplication as a speed optimization; this actually made a significant difference!</p>

<p>``` python Project Euler Problem 2 the Generator Way
def modfib():</p>

<pre><code>a,b = 0,1
while b &lt; 4000000:
    a,b = a + b + b, a + a + b + b + b
    yield a
</code></pre>

<p>print sum(modfib())
```</p>
]]></content>
  </entry>
  
</feed>
